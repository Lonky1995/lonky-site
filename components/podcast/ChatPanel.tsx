"use client";

import { useState, useRef, useEffect, useCallback, useMemo } from "react";
import { renderMarkdown } from "@/lib/podcast/render-markdown";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

type ChatPanelProps = {
  transcript: string;
  meta: { title: string; description?: string };
  systemPrompt: string;
  secret: string;
  onSummaryComplete?: (summary: string) => void;
  skipInitialSummary?: boolean;
  onMessagesChange?: (messages: Message[]) => void;
};

export function ChatPanel({
  transcript,
  meta,
  systemPrompt,
  secret,
  onSummaryComplete,
  skipInitialSummary = false,
  onMessagesChange,
}: ChatPanelProps) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const summaryExtracted = useRef(false);
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const abortRef = useRef<AbortController | null>(null);
  // Remember if this instance auto-generated summary (stable across re-renders)
  const wasAutoGenerated = useRef(!skipInitialSummary);
  // Track if user has manually scrolled up
  const userScrolledUp = useRef(false);

  useEffect(() => {
    // Only auto-scroll if user hasn't scrolled up
    if (!userScrolledUp.current && scrollContainerRef.current) {
      scrollContainerRef.current.scrollTop = scrollContainerRef.current.scrollHeight;
    }
    // Report only discussion messages to parent
    if (onMessagesChange) {
      const chatOnly = wasAutoGenerated.current
        ? messages.slice(2)  // Skip [0]=transcript prompt, [1]=auto summary
        : messages;           // All messages are real chat (restored session)
      onMessagesChange(chatOnly);
    }
  }, [messages]);

  const sendMessage = useCallback(
    async (userContent: string, allMessages: Message[]) => {
      setIsLoading(true);

      const newMessages = [
        ...allMessages,
        { id: crypto.randomUUID(), role: "user" as const, content: userContent },
      ];
      setMessages(newMessages);

      const assistantId = crypto.randomUUID();
      setMessages((prev) => [
        ...prev,
        { id: assistantId, role: "assistant", content: "" },
      ]);

      try {
        abortRef.current = new AbortController();

        const apiMessages = newMessages.map((m) => ({
          role: m.role,
          content: m.content,
        }));

        const res = await fetch("/api/podcast/chat", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${secret}`,
          },
          body: JSON.stringify({ messages: apiMessages, system: systemPrompt }),
          signal: abortRef.current.signal,
        });

        if (!res.ok) throw new Error(`API error: ${res.status}`);
        if (!res.body) throw new Error("No response body");

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let fullContent = "";

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          fullContent += chunk;

          setMessages((prev) =>
            prev.map((m) =>
              m.id === assistantId ? { ...m, content: fullContent } : m
            )
          );
        }

        // First assistant response = summary
        if (!summaryExtracted.current && onSummaryComplete) {
          summaryExtracted.current = true;
          onSummaryComplete(fullContent);
        }
      } catch (e) {
        if ((e as Error).name !== "AbortError") {
          setMessages((prev) =>
            prev.map((m) =>
              m.id === assistantId
                ? { ...m, content: `Error: ${(e as Error).message}` }
                : m
            )
          );
        }
      } finally {
        setIsLoading(false);
      }
    },
    [secret, systemPrompt, onSummaryComplete]
  );

  // Auto-trigger summary generation on mount (skip if restored)
  useEffect(() => {
    if (skipInitialSummary) return;
    const initialPrompt = `以下是播客「${meta.title}」的完整转录：\n\n${transcript}\n\n请根据以上转录内容，生成结构化播客笔记。`;
    sendMessage(initialPrompt, []);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim() || isLoading) return;
    const text = input;
    setInput("");
    sendMessage(text, messages);
  };

  // Filter out initial transcript prompt (and auto summary) from display
  const displayMessages = skipInitialSummary
    ? messages
    : messages.filter((m, i) => !(i === 0 && m.role === "user"));

  return (
    <div className="flex flex-col rounded-xl border border-border bg-card">
      {/* Messages area */}
      <div
        ref={scrollContainerRef}
        className="max-h-[500px] overflow-y-auto p-4 space-y-4"
        onScroll={() => {
          const el = scrollContainerRef.current;
          if (!el) return;
          // If user is within 50px of bottom, re-enable auto-scroll
          const atBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 50;
          userScrolledUp.current = !atBottom;
        }}
      >
        {displayMessages.length === 0 && isLoading && (
          <div className="text-sm text-muted animate-pulse">
            AI 正在生成笔记...
          </div>
        )}
        {displayMessages.map((m) => (
          <MessageBubble key={m.id} message={m} />
        ))}
        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <form
        onSubmit={handleSubmit}
        className="flex items-end gap-2 border-t border-border p-4"
      >
        <textarea
          value={input}
          onChange={(e) => {
            setInput(e.target.value);
            // Auto-resize
            e.target.style.height = "auto";
            e.target.style.height = Math.min(e.target.scrollHeight, 72) + "px";
          }}
          onKeyDown={(e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              handleSubmit(e);
            }
          }}
          placeholder="继续讨论这期播客..."
          rows={1}
          className="flex-1 resize-none rounded-lg border border-border bg-background px-4 py-2 text-sm text-foreground placeholder:text-muted focus:border-accent focus:outline-none"
          style={{ maxHeight: 72 }}
          disabled={isLoading}
        />
        <button
          type="submit"
          disabled={isLoading || !input.trim()}
          className="rounded-lg bg-accent px-4 py-2 text-sm font-medium text-white transition-opacity hover:opacity-90 disabled:opacity-50"
        >
          发送
        </button>
      </form>
    </div>
  );
}

function MessageBubble({ message }: { message: Message }) {
  const html = useMemo(
    () => (message.role === "assistant" && message.content ? renderMarkdown(message.content) : ""),
    [message.role, message.content]
  );

  const isUser = message.role === "user";

  return (
    <div className={`flex ${isUser ? "justify-end" : "justify-start"}`}>
      <div className={`text-sm ${isUser ? "max-w-[80%]" : "max-w-full w-full"}`}>
        <div className={`mb-1 text-xs font-medium text-muted ${isUser ? "text-right" : ""}`}>
          {isUser ? "You" : "AI"}
        </div>
        {isUser ? (
          <div className="select-text cursor-text rounded-2xl rounded-tr-sm bg-accent px-4 py-2.5 text-white whitespace-pre-wrap">
            {message.content}
          </div>
        ) : message.content ? (
          <div
            className="select-text cursor-text rounded-2xl rounded-tl-sm border border-border bg-card px-4 py-3 prose-custom prose-sm max-w-none"
            dangerouslySetInnerHTML={{ __html: html }}
          />
        ) : (
          <div className="rounded-2xl rounded-tl-sm border border-border bg-card px-4 py-3">
            <span className="animate-pulse text-muted">...</span>
          </div>
        )}
      </div>
    </div>
  );
}
